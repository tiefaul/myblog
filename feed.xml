<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://www.levitatecold.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://www.levitatecold.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-09T22:26:05+00:00</updated><id>https://www.levitatecold.com/feed.xml</id><title type="html">Tyler Faulhaber</title><subtitle>Welcome to Tyler&apos;s IT Insights, where I document my journey through the world of technology. From coding projects and homelab experiments to insights on cybersecurity, cloud computing, and more—join me as I explore, learn, and share my experiences in the ever-evolving IT landscape. </subtitle><entry><title type="html">Dockerizing Django Application</title><link href="https://www.levitatecold.com/blog/2024/Dockerizing-Django/" rel="alternate" type="text/html" title="Dockerizing Django Application"/><published>2024-11-03T15:38:00+00:00</published><updated>2024-11-03T15:38:00+00:00</updated><id>https://www.levitatecold.com/blog/2024/Dockerizing-Django</id><content type="html" xml:base="https://www.levitatecold.com/blog/2024/Dockerizing-Django/"><![CDATA[<p>Starting a new project is always exciting, especially when it brings together technologies like Django and Docker. For this project, I decided to build a to-do application using Django as the web framework. To simplify development and ensure consistency across environments, I set up a Docker container and a Docker Compose file. This setup allows for seamless deployment, making it as simple as running a single command to launch the app.</p> <p>In this blog, I’ll guide you through creating the Dockerfile and using Docker Compose to automate container setup, along with a special Nginx configuration to enhance the deployment. As someone aspiring to enter DevOps, I believe it’s crucial to understand the fundamentals of web frameworks. Exploring concepts like virtual environments, pipfiles, piplocks, environment variables, and configuring web servers like Nginx has been both educational and a lot of fun.</p> <p>If you’re new to Django, I highly recommend following a tutorial on building a web app with it. This not only broadens your Python skills but also introduces you to HTML, CSS, and other tools that can make an application visually engaging.</p> <hr/> <h2 id="create-a-django-application">Create a Django Application</h2> <p>As I mentioned earlier, diving into Django is a great way to get comfortable with its functionality and structure. To start, I worked through the official Django documentation’s <a href="https://docs.djangoproject.com/en/5.1/">polling application tutorial</a>, which helped me understand the basics. From there, I chose to build a simple application of my own —to-do list app— as a foundation to practice and experiment with new features.</p> <p>After some research, I decided to follow the <a href="https://realpython.com/django-todo-lists/">Real Python tutorial on creating a Django to-do list</a>. If you’re interested in learning alongside me, I encourage you to try building this application first. Then, come back here to see how we can containerize it with Docker and deploy it locally on your home network.</p> <hr/> <h2 id="creating-a-dockerfile">Creating a Dockerfile</h2> <p>A Dockerfile is a script containing a series of instructions that tells Docker how to build a custom container image. You specify things like the base image (e.g., Python or Ubuntu), the application code, required libraries, and any setup commands needed to get your app up and running. When you build this file, Docker uses these instructions to create a container image that you can deploy consistently across different environments.</p> <h3 id="the-dockerfile">The DockerFile</h3> <p>Here’s a basic Dockerfile for a Django application:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># First we import the python image from DockerHub (https://hub.docker.com/_/python)</span>

<span class="s">FROM python:3.12</span>

<span class="c1"># Standard environment variables when creating a python based dockerfile</span>
<span class="c1"># First env tells python not to write .pyc files. These files are unnecessary for a container.</span>
<span class="c1"># Second env tells python to output directly into the console without buffering</span>

<span class="s">ENV PYTHONDONTWRITEBYTECODE=1</span>
<span class="s">ENV PYTHONUNBUFFERED=1</span> 

<span class="c1"># Make a directory called app to store your django project, update any packages, and update pip</span>

<span class="s">RUN mkdir /app &amp;&amp; \</span> 
    <span class="s">apt update &amp;&amp; \</span>
    <span class="s">pip install --upgrade pip</span>

<span class="c1"># Set the new directory as the working directory    </span>

<span class="s">WORKDIR /app</span>

<span class="c1"># Copy all the files in your current directory on your host to the current directory of the container</span>

<span class="s">COPY . .</span>

<span class="c1"># Run commands to install the requirements from your requirements.txt</span>

<span class="s">RUN pip install -r requirements.txt</span>

<span class="c1"># Expose port 8000</span>

<span class="s">EXPOSE </span><span class="m">8000</span>

<span class="c1"># Commands to run when container is finished. Seperate each string with a comma.</span>

<span class="s">CMD ["gunicorn", "-b", "0.0.0.0:8000", "todo_website.wsgi:application"]</span>
</code></pre></div></div> <h3 id="why-we-use-gunicorn">Why we use Gunicorn</h3> <p>By default Django’s development server, <code class="language-plaintext highlighter-rouge">python manage.py runserver</code>, is intended for development and is not optimized for handling multiple requests at scale or ensuring stability needed in production.</p> <p>Gunicorn is bridge between Django and the web, efficiently handling multiple incoming requests by spawning multiple worker processes that manage these requests concurrently. This makes the app more responsive and capable of handling higher traffic volumes.</p> <p>In a typical setup, Gunicorn is often used together with a web server like Nginx. Nginx handles static file serving, load balancing, and reverse proxying to Gunicorn, which then processes the actual application requests. This combination helps ensure performance, stability, and security for Django applications in production environments</p> <p>Here is an example of a Nginx config for Gunicorn:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf</span>

<span class="s">server {</span>
    <span class="s">listen 80;</span>

    <span class="s"># Replace this with your domain or IP</span>
    <span class="s">server_name example.domain.com;</span>

    <span class="s"># Serve static files</span>
    <span class="s">location /static/ {</span> <span class="c1"># This block tells nginx to handle requests that start with /static/</span>
        <span class="s">alias /app/static/;</span> <span class="c1"># This sets /app/static/ as the directory where nginx should look for the files requested under /static/</span>
    <span class="err">}</span>

    <span class="c1"># Proxy requests to Gunicorn</span>
    <span class="s">location / {</span>
        <span class="s">proxy_pass http://web:8000;</span> <span class="c1"># web is based on the service name in the docker compose file</span>
        <span class="s">proxy_set_header Host $host;</span> 
        <span class="s">proxy_set_header X-Real-IP $remote_addr;</span>
        <span class="s">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span>
        <span class="s">proxy_set_header X-Forwarded-Proto $scheme;</span>
    <span class="s">}</span>
<span class="err">}</span>
</code></pre></div></div> <hr/> <h2 id="creating-the-docker-compose">Creating the Docker Compose</h2> <p>Docker Compose is a tool that simplifies the process of managing multi-container Docker applications. With Docker Compose, you can define all the services, networks, and volumes your app needs in a single <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> file. This will specify how each container should be configured, such as which Docker image to use, any environment variables, and how containers should interact.</p> <p>Here is an example of my <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> file:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">todoapp</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span> <span class="c1"># service name</span>
    <span class="na">build</span><span class="pi">:</span> <span class="c1"># This tells Docker to generate the image directly from the project's Dockerfile instead of using a pre-built one like we did for nginx.</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">.</span> <span class="c1"># Defines a path to a directory that contains a Dockerfile, or a URL to a git repo.</span>
      <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile</span> <span class="c1"># Can set an alternate Dockerfile. So this file could be called "app.Dockerfile".</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">static_volume:/app/static/</span> <span class="c1"># Stores our static files</span>
      <span class="pi">-</span> <span class="s">./db.sqlite3:/app/db.sqlite3</span> <span class="c1"># Mount the SQLite database file if you want to persist it.</span>
    <span class="na">expose</span><span class="pi">:</span> <span class="c1"># Expose is only used to connect to other services in the Dockerfile</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8000"</span>
    
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="na">ports</span><span class="pi">:</span> <span class="c1"># Ports is used if you want clients/services outside of the Dockerfile to connect.</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">static_volume:/app/static</span> <span class="c1"># Link the same static files directory</span>
      <span class="pi">-</span> <span class="s">./nginx.conf:/etc/nginx/conf.d/default.conf</span> <span class="c1"># Replace the contents of nginx.conf into the default.conf of nginx.</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">web</span> <span class="c1"># Nginx should depend on the web service, it gets built after the web service.</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">static_volume</span><span class="pi">:</span> <span class="c1"># Create the static_volume</span>
</code></pre></div></div> <p>Here you can see I have two services. The first service image is the DockerFile I created in my apps root directory. The second service is a Nginx image pulled from DockerHub. With this setup, when I run <code class="language-plaintext highlighter-rouge">docker compose up</code>, Docker will build both these containers and set up how they should connect to each other. This makes it much easier to deploy and manage complex applications.</p>]]></content><author><name></name></author><category term="docker"/><category term="docker-compose"/><category term="django"/><category term="python"/><category term="nginx"/><summary type="html"><![CDATA[Using docker compose to containerize my Django application]]></summary></entry><entry><title type="html">InfluxDB and Grafana</title><link href="https://www.levitatecold.com/blog/2024/Grafana-Dashboard/" rel="alternate" type="text/html" title="InfluxDB and Grafana"/><published>2024-09-15T16:23:00+00:00</published><updated>2024-09-15T16:23:00+00:00</updated><id>https://www.levitatecold.com/blog/2024/Grafana-Dashboard</id><content type="html" xml:base="https://www.levitatecold.com/blog/2024/Grafana-Dashboard/"><![CDATA[<p>In managing a homelab, keeping a eye on my server’s performance is crucial for maintaining stability and optimizing resource usage. As I expanded my Proxmox environment, I wanted a better way to monitor the health of my server in real-time. The provided monitoring for my server given by proxmox itself was very limited and felt lacking. However, it was a nice feature given that the purpose of Proxmox as a whole isn’t just for monitoring. After researching various options, I decided to set up a monitoring solution using <strong>InfluxDB</strong> and <strong>Grafana</strong>. InfluxDB is a high performance time-series database, perfect for storing metrics, while Grafana provides rich, customizable visualizations.</p> <p>In this post, I will discuss with you how I integrated these tools to monitor my Proxmox server. From setting up InfluxDB to visualizing metrics in Grafana.</p> <hr/> <h2 id="creating-the-docker-compose">Creating the docker compose</h2> <p>After reading various documents, reddit post, videos, etc. I came to a conclusion that I would create docker containers for both Grafana and InfluxDB. Given that both have verified publishers for their containers on <a href="https://hub.docker.com/">Docker Hub</a> I felt comfortable moving forward with my decision.</p> <p>Step 1:<br/> Create a directory to store the compose file.<br/></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>monitoring
</code></pre></div></div> <p>Use the <code class="language-plaintext highlighter-rouge">ls</code> command to verify the directory was made.</p> <p>Step 2:<br/> Create the compose file.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch </span>compose.yaml
</code></pre></div></div> <p>Step 3:<br/> Use your favorite editor to edit the compose file.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">grafana</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">grafana/grafana</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">grafana</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">3089:3089</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitoring_network</span> <span class="c1"># mount network</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./conf:/usr/share/grafana/conf</span> <span class="c1"># mount server "conf" file to the container "conf" file, whatever changes are made to the server "conf" file are changed on the container "conf" file when restarted</span>
      <span class="pi">-</span> <span class="s">grafana-volume:/var/lib/grafana</span> <span class="c1"># mount grafana-volume</span>

  <span class="na">influxdb</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">influxdb</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">influxdb</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8086:8086</span>
      <span class="pi">-</span> <span class="s">8089:8089/udp</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitoring_network</span> <span class="c1">#mount network</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb-volume-config:/etc/influxdb2</span>
      <span class="pi">-</span> <span class="s">influxdb-volume:/var/lib/influxdb2</span> <span class="c1"># mount influxdb-volume</span>

<span class="na">networks</span><span class="pi">:</span>
  <span class="na">monitoring_network</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># Use this when the network is already created using &lt;docker network create "name"&gt;</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">grafana-volume</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># Use this when the volume is already created using &lt;docker volume create "name"&gt;</span>
  <span class="na">influxdb-volume</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">influxdb-volume-config</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <blockquote> <p>Please note that the <code class="language-plaintext highlighter-rouge">./conf</code> volume on the Grafana service was necessary for me because I needed to change the default port of 3000 to 3089 inside the <code class="language-plaintext highlighter-rouge">default.ini</code> file of the container. So if you do not need to change the port, use the recommended port option of 3000 for the Grafana service and remove the <code class="language-plaintext highlighter-rouge">./conf</code> volume.</p> </blockquote> <hr/> <h2 id="create-your-volume-and-network">Create your volume and network</h2> <p>In our compose file we set the network and volumes to <code class="language-plaintext highlighter-rouge">external: true</code> meaning we have to create these resources ourselves or else the compose file will error out because it cannot find the volume or network.</p> <p>Run these commands to create our volumes and network:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker volume create grafana-volume
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker volume create influxdb-volume
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker volume create influxdb-volume-config
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create monitoring_network
</code></pre></div></div> <p>You can use <code class="language-plaintext highlighter-rouge">docker volume ls</code> and <code class="language-plaintext highlighter-rouge">docker network ls</code> to list out your current networks/volumes you have on your environment.</p> <hr/> <h2 id="testing-your-creations">Testing your creations!</h2> <p>Run <code class="language-plaintext highlighter-rouge">docker compose up -d</code> to run docker in detach mode and wait a few minutes.</p> <p>Run <code class="language-plaintext highlighter-rouge">docker ps -a</code> to list all of your docker containers and you can view the status of the containers you just created.</p> <p>Navigate to your containers. <code class="language-plaintext highlighter-rouge">&lt;serverip:8086&gt;</code> for InfluxDB and <code class="language-plaintext highlighter-rouge">&lt;serverip:3000&gt;</code> for Grafana. Unless you changed your ports like I did, then you should be good to go. I added all my services to my <strong>Homepage</strong> dashboard for easier navigation between all my services. I will make a post going over what Homepage is in a later post, but for now if you are interested, here is a GitHub link to <a href="https://github.com/gethomepage/homepage">HomePage</a>. Once inside your containers. Make sure you create a account in InfluxDB and the default username and password for Grafana is admin:admin. Once you are in your instances I highly recommend watching Christian Lempa’s video <a href="https://www.youtube.com/watch?v=f2eyVfCTLi0&amp;t=403s">My new Proxmox Monitoring Tools: InfluxDB2 + Grafana</a> on what to do next. He goes over what I went through and MORE!</p> <hr/> <h2 id="what-should-i-do-now">What should I do now?</h2> <p>Just like you I was confused on how everything worked and what to do next. When watching Christian Lempa’s video, I imported the <a href="https://grafana.com/grafana/dashboards/15356-proxmox-cluster-flux/">Proxmox Cluster [Flux]</a> dashboard from the <a href="https://grafana.com/">Grafana website</a>, but I felt as if I wasn’t learning anything from doing that, even though the dashboard is great and amazing and provides me with everything I want from a monitoring standpoint. My next objective in this learning journey is to create my own dashboard, learn a little bit of flux, and see how everything pans out.</p>]]></content><author><name></name></author><category term="monitoring"/><category term="database"/><category term="flux"/><category term="grafana"/><category term="influxdb"/><category term="walkthrough"/><summary type="html"><![CDATA[Using flux and grafana to monitor my Proxmox server]]></summary></entry><entry><title type="html">Hosting my first website</title><link href="https://www.levitatecold.com/blog/2024/Jekyll-Website/" rel="alternate" type="text/html" title="Hosting my first website"/><published>2024-08-11T16:10:00+00:00</published><updated>2024-08-11T16:10:00+00:00</updated><id>https://www.levitatecold.com/blog/2024/Jekyll-Website</id><content type="html" xml:base="https://www.levitatecold.com/blog/2024/Jekyll-Website/"><![CDATA[<p>When I first decided to create my own personal website, I was faced with a common dilemma: which platform should I use? The obvious choice seemed to be website builders like Wix, Squarespace, and Weebly given there simplicity and popularity. However, as I explored my options, I found myself drawn to something more customizable and developer-friendly…. <strong>Jekyll</strong>.</p> <hr/> <h2 id="why-jekyll">Why Jekyll?</h2> <p>One of the main reasons to I chose Jekyll is the unparalleled flexibility it offers. Unlike Wordpress, which can sometimes feel restrictive with its themes and plugins, Jekyll gives me complete control over every aspect of my website. From the layout and design to the functionality and content structure, I can tailor anything to match my vision if I wanted to do so. This level of customization was exactly what I was looking for as someone who enjoys tinkering and learning new things with code and experimenting with different ideas.</p> <hr/> <h2 id="integration-with-github-pages">Integration with GitHub Pages</h2> <p>Another significant advantage of Jekyll is its seamless integration with <strong>Github Pages</strong>. As someone who loves exploring projects on GitHub, I was excited to use a platform that works so well with Git’s version control system. With Jekyll, I can host my website directly from a GitHub repository, making it easy to manage updates, track changes, and collaborate with others if needed. Plus, deploying the site is as simple as pushing commits to my repository—no need to worry about complex setups or hosting fees.</p> <hr/> <h2 id="the-appeal-of-using-wsl-and-git">The Appeal of Using WSL and Git</h2> <p>I wanted to learn more about using <strong>Windows Subsystem for Linux</strong> (WSL) and <strong>Git</strong>. With Jekyll, I could easily set up my development environment on WSL, clone my repository using Git, and manage my site entirely from the command line. So not am I only getting more hands on with using Git commands, I am learning how to traverse through a linux environment right on my windows system, thanks to WSL! This hands-on approach allowed me to deepen my understanding of version control and site deployment, skills that I wanted to develop as a someone who is eager to learn new things in IT.</p> <hr/> <h2 id="performance-and-security">Performance and Security</h2> <p>Jekyll’s static site generation also stood out to me for its performance and security benefits. Jekyll generates static HTML files so that my website loads faster and is less vulnerable to attacks compared to a dynamic WordPress site that relies on a database. This means I can focus on creating more content and less on dealing with potential security issues or performance bottlenecks.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>In the end, Jekyll was the clear winner for me because it provided the perfect balance of flexibility, control, and learning potential. It is a platform that aligned with my passion for coding and understanding CI/CD pipelines, as well as heightening other skills. If you are looking for a powerful and developer-friendly way to build a website, I highly recommend giving Jekyll a try. Thank you for taking the time to read my story, and I look forward to sharing more about my experiences and giving you all tutorials on how I manage to accomplish everything you see here and in future posts!</p> <hr/> <h2 id="links">Links</h2> <p>I’d also like to give a special shoutout to <a href="https://github.com/alshedivat">Reddit user alshedivat</a> and their 209 contributors for creating the fantastic <a href="https://github.com/alshedivat/al-folio">ai-folio template</a>, which has been incredibly helpful in my Jekyll journey. If you’re interested in learning more about Jekyll, be sure to check out the official <a href="https://jekyllrb.com/">Jekyll website</a>. And for anyone looking for high-quality themes, I highly recommend exploring the <a href="https://github.com/topics/jekyll-theme">jekyll-theme repository on GitHub</a>.</p>]]></content><author><name></name></author><category term="Jekyll"/><category term="hosting"/><category term="website"/><summary type="html"><![CDATA[Learning how to set up and host my own website using Jekyll.]]></summary></entry></feed>